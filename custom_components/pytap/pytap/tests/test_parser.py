"""Tests for the core protocol parser."""

import pytest
from pytap.core.parser import Parser
from pytap.core.crc import crc


# -----------------------------------------------------------------------
#  ENUMERATION_SEQUENCE test data (from Appendix B of implementation plan)
# -----------------------------------------------------------------------

ENUMERATION_SEQUENCE = bytes([
    0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x01, 0x0B, 0x00, 0x01, 0xFE, 0x83, 0x7E, 0x08, 0xFF, 0x7E,
    0x07, 0x92, 0x01, 0x0B, 0x01, 0x01, 0x73, 0x10, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x00,
    0x00, 0x00, 0x14, 0x37, 0x7E, 0x01, 0x92, 0x66, 0x12, 0x35, 0x06, 0x1A, 0x7E, 0x08, 0xFF, 0x7E,
    0x07, 0x80, 0x00, 0x00, 0x15, 0x17, 0xE0, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x00, 0x00,
    0x00, 0x14, 0x37, 0x7E, 0x01, 0x92, 0x66, 0x12, 0x35, 0x06, 0x1A, 0x7E, 0x08, 0xFF, 0x7E, 0x07,
    0x80, 0x00, 0x00, 0x15, 0x17, 0xE0, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x00, 0x00, 0x00,
    0x14, 0x37, 0x7E, 0x01, 0x92, 0x66, 0x12, 0x35, 0x06, 0x1A, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x80,
    0x00, 0x00, 0x15, 0x17, 0xE0, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x00, 0x00, 0x00, 0x14,
    0x37, 0x7E, 0x01, 0x92, 0x66, 0x12, 0x35, 0x06, 0x1A, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x80, 0x00,
    0x00, 0x15, 0x17, 0xE0, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x00, 0x00, 0x00, 0x14, 0x37,
    0x7E, 0x01, 0x92, 0x66, 0x12, 0x35, 0x06, 0x1A, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x80, 0x00, 0x00,
    0x15, 0x17, 0xE0, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x35, 0x00, 0x38, 0x5A, 0x72,
    0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92, 0x35, 0x00, 0x39, 0x04, 0xC0, 0x5B, 0x30, 0x00, 0x02, 0xBE,
    0x16, 0x12, 0x35, 0xA7, 0x83, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x35, 0x00, 0x3C,
    0x37, 0x7E, 0x01, 0x92, 0x66, 0x04, 0xC0, 0x5B, 0x30, 0x00, 0x02, 0xBE, 0x16, 0x12, 0x01, 0x58,
    0x0B, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92, 0x35, 0x00, 0x3D, 0x99, 0x08, 0x7E, 0x08, 0x00, 0xFF,
    0xFF, 0x7E, 0x07, 0x12, 0x35, 0x00, 0x38, 0x5A, 0x72, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07,
    0x12, 0x35, 0x00, 0x38, 0x5A, 0x72, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x35, 0x00,
    0x38, 0x5A, 0x72, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x35, 0x00, 0x38, 0x5A, 0x72,
    0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x35, 0x00, 0x38, 0x5A, 0x72, 0x7E, 0x08, 0x00,
    0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x01, 0x00, 0x3A, 0x87, 0xB4, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92,
    0x01, 0x00, 0x3B, 0x04, 0xC0, 0x5B, 0x30, 0x00, 0x02, 0xBE, 0x16, 0x12, 0x01, 0xE6, 0xA6, 0x7E,
    0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x01, 0x00, 0x3C, 0x37, 0x7E, 0x01, 0x92, 0x66, 0x04,
    0xC0, 0x5B, 0x30, 0x00, 0x02, 0xBE, 0x16, 0x12, 0x02, 0xDC, 0x60, 0x7E, 0x08, 0xFF, 0x7E, 0x07,
    0x92, 0x01, 0x00, 0x3D, 0x56, 0xED, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x02, 0x00,
    0x3A, 0xE3, 0x5B, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92, 0x02, 0x00, 0x3B, 0x04, 0xC0, 0x5B, 0x30,
    0x00, 0x02, 0xBE, 0x16, 0x12, 0x02, 0x8A, 0x9A, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x00,
    0x00, 0x00, 0x10, 0x37, 0x7E, 0x01, 0x92, 0x66, 0xC3, 0x27, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x80,
    0x00, 0x00, 0x11, 0x33, 0xA6, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x01, 0x00, 0x3A,
    0x87, 0xB4, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92, 0x01, 0x00, 0x3B, 0x04, 0xC0, 0x5B, 0x30, 0x00,
    0x02, 0xBE, 0x16, 0x12, 0x01, 0xE6, 0xA6, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x01,
    0x00, 0x0A, 0x04, 0x85, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92, 0x01, 0x00, 0x0B, 0x4D, 0x67, 0x61,
    0x74, 0x65, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x47, 0x38, 0x2E, 0x35, 0x39,
    0x0D, 0x4A, 0x75, 0x6C, 0x20, 0x20, 0x36, 0x20, 0x32, 0x30, 0x32, 0x30, 0x0D, 0x31, 0x36, 0x3A,
    0x35, 0x31, 0x3A, 0x35, 0x31, 0x0D, 0x47, 0x57, 0x2D, 0x48, 0x31, 0x35, 0x38, 0x2E, 0x34, 0x2E,
    0x33, 0x53, 0x30, 0x2E, 0x31, 0x32, 0x0D, 0x8A, 0xE2, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07,
    0x12, 0x01, 0x0E, 0x02, 0x5C, 0x93, 0x7E, 0x08, 0xFF, 0x7E, 0x07, 0x92, 0x01, 0x00, 0x06, 0x06,
    0x62, 0x7E, 0x08, 0x00, 0xFF, 0xFF, 0x7E, 0x07, 0x12, 0x01, 0x0B, 0x00, 0x01, 0xFE, 0x83, 0x7E,
    0x08, 0xFF, 0x7E, 0x07, 0x92, 0x01, 0x0B, 0x01, 0x01, 0x73, 0x10, 0x7E, 0x08,
])


# -----------------------------------------------------------------------
#  Test 1: Frame accumulation
# -----------------------------------------------------------------------

def test_frame_accumulation():
    """Feed a valid frame with preamble/terminator, get Frame back."""
    parser = Parser()
    # Build: address(2) + frame_type(2) + payload + crc(2)
    body = bytes([0x12, 0x01, 0x0B, 0x00, 0x01])  # addr=0x1201, type=PING_REQUEST, payload=0x01
    c = crc(body)
    raw = bytes([0xFF, 0x7E, 0x07]) + body + c.to_bytes(2, 'little') + bytes([0x7E, 0x08])
    events = parser.feed(raw)
    assert parser.counters['frames_received'] == 1
    assert parser.counters['crc_errors'] == 0


# -----------------------------------------------------------------------
#  Test 2: CRC error
# -----------------------------------------------------------------------

def test_crc_error():
    parser = Parser()
    body = bytes([0x12, 0x01, 0x0B, 0x00, 0x01])
    raw = bytes([0x7E, 0x07]) + body + bytes([0xFF, 0xFF]) + bytes([0x7E, 0x08])
    parser.feed(raw)
    assert parser.counters['crc_errors'] == 1
    assert parser.counters['frames_received'] == 0


# -----------------------------------------------------------------------
#  Test 3: Runt frame
# -----------------------------------------------------------------------

def test_runt():
    parser = Parser()
    # Only 2 body bytes — need at least 6 (2 addr + 2 type + 2 crc)
    raw = bytes([0x7E, 0x07, 0xAA, 0xBB, 0x7E, 0x08])
    parser.feed(raw)
    assert parser.counters['runts'] == 1


# -----------------------------------------------------------------------
#  Test 4: Enumeration sequence
# -----------------------------------------------------------------------

def test_enumeration_sequence():
    """Feed the full enumeration sequence and verify infrastructure discovery."""
    parser = Parser()
    events = parser.feed(ENUMERATION_SEQUENCE)

    # Should parse many frames without errors
    assert parser.counters['frames_received'] > 10
    assert parser.counters['crc_errors'] == 0

    # Should discover infrastructure
    infra = parser.infrastructure
    assert 'gateways' in infra
    # Gateway address 04:C0:5B:30:00:02:BE:16 should be discovered
    found_address = False
    for gw_id, gw_info in infra['gateways'].items():
        if gw_info.get('address') == '04:C0:5B:30:00:02:BE:16':
            found_address = True
            break
    assert found_address, f"Expected gateway address not found in {infra['gateways']}"


def test_enumeration_sequence_version_string():
    """The version string should be discovered from the enumeration sequence."""
    parser = Parser()
    parser.feed(ENUMERATION_SEQUENCE)
    infra = parser.infrastructure
    found_version = False
    for gw_info in infra['gateways'].values():
        v = gw_info.get('version', '')
        if v and 'Mgate Version G8.59' in v:
            found_version = True
            break
    assert found_version, f"Expected version string not found in {infra['gateways']}"


# -----------------------------------------------------------------------
#  Test 5: Byte-at-a-time feeding
# -----------------------------------------------------------------------

def test_byte_at_a_time():
    """Same data as test_frame_accumulation but feed one byte per call."""
    parser = Parser()
    body = bytes([0x12, 0x01, 0x0B, 0x00, 0x01])
    c = crc(body)
    raw = bytes([0xFF, 0x7E, 0x07]) + body + c.to_bytes(2, 'little') + bytes([0x7E, 0x08])

    all_events = []
    for byte in raw:
        all_events.extend(parser.feed(bytes([byte])))

    assert parser.counters['frames_received'] == 1
    assert parser.counters['crc_errors'] == 0


# -----------------------------------------------------------------------
#  Test 6: Escape handling
# -----------------------------------------------------------------------

def test_escape_handling():
    """Build a frame whose body contains bytes that need escaping."""
    parser = Parser()
    # Body with a 0x24 byte that should be escaped as 0x7E 0x01
    body = bytes([0x12, 0x01, 0x0B, 0x00, 0x24])
    c = crc(body)
    body_with_crc = body + c.to_bytes(2, 'little')

    # Manually escape the body
    escaped = bytearray()
    escape_map = {0x7E: 0x00, 0x24: 0x01, 0x23: 0x02, 0x25: 0x03,
                  0xA4: 0x04, 0xA3: 0x05, 0xA5: 0x06}
    for b in body_with_crc:
        if b in escape_map:
            escaped.extend([0x7E, escape_map[b]])
        else:
            escaped.append(b)

    raw = bytes([0xFF, 0x7E, 0x07]) + bytes(escaped) + bytes([0x7E, 0x08])
    events = parser.feed(raw)
    assert parser.counters['frames_received'] == 1
    assert parser.counters['crc_errors'] == 0


# -----------------------------------------------------------------------
#  Test 7: Giant frame
# -----------------------------------------------------------------------

def test_giant_frame():
    """Feed a frame with >256 body bytes — should be counted as giant, no crash."""
    parser = Parser()
    # Build a body longer than 256 bytes using only safe bytes (no 0x7E or other escape chars)
    safe_bytes = [b for b in range(256) if b not in (0x7E, 0x24, 0x23, 0x25, 0xA4, 0xA3, 0xA5)]
    body = bytes(safe_bytes) + bytes([0x01] * 50)  # >256 safe bytes
    raw = bytes([0x7E, 0x07]) + body + bytes([0x7E, 0x08])
    parser.feed(raw)
    assert parser.counters['giants'] >= 1


# -----------------------------------------------------------------------
#  Test 8: Multiple feeds mid-frame
# -----------------------------------------------------------------------

def test_split_across_feeds():
    """Data split across two feed() calls mid-frame should still parse correctly."""
    parser = Parser()
    body = bytes([0x12, 0x01, 0x0B, 0x00, 0x01])
    c = crc(body)
    raw = bytes([0xFF, 0x7E, 0x07]) + body + c.to_bytes(2, 'little') + bytes([0x7E, 0x08])

    # Split in the middle
    mid = len(raw) // 2
    parser.feed(raw[:mid])
    events = parser.feed(raw[mid:])

    assert parser.counters['frames_received'] == 1
    assert parser.counters['crc_errors'] == 0


# -----------------------------------------------------------------------
#  Test 9: Parser reset
# -----------------------------------------------------------------------

def test_parser_reset():
    """Parser reset clears frame state but not infrastructure."""
    parser = Parser()
    parser.feed(ENUMERATION_SEQUENCE)
    assert parser.counters['frames_received'] > 0

    parser.reset()
    # After reset, feeding a partial frame should not cause issues
    parser.feed(bytes([0xFF, 0x7E, 0x07]))
    # Should still have counters from before
    assert parser.counters['frames_received'] > 0


# -----------------------------------------------------------------------
#  Test 10: Infrastructure events from enumeration
# -----------------------------------------------------------------------

def test_enumeration_produces_infrastructure_events():
    """Feeding enumeration data should produce InfrastructureEvent instances."""
    parser = Parser()
    events = parser.feed(ENUMERATION_SEQUENCE)
    infra_events = [e for e in events if e.event_type == 'infrastructure']
    assert len(infra_events) >= 1
