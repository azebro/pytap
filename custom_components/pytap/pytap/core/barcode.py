"""Tigo device barcode encoding and decoding.

Implements the Tigo barcode format: X-NNNNNNNC
- X: leading nibble (hex digit)
- NNNNNNN: 7-digit hex payload (variable length, no leading zeros)
- C: CRC check character from the barcode alphabet

Only addresses with prefix 04:C0:5B are barcode-eligible.
"""

from typing import Optional


# 16-character barcode alphabet (no vowels)
_ALPHABET = 'GHJKLMNPRSTVWXYZ'

# Barcode CRC lookup table (256 entries, 4-bit values)
_CRC_TABLE = [
    0x0, 0x3, 0x6, 0x5, 0xc, 0xf, 0xa, 0x9, 0xb, 0x8, 0xd, 0xe, 0x7, 0x4, 0x1, 0x2,
    0x5, 0x6, 0x3, 0x0, 0x9, 0xa, 0xf, 0xc, 0xe, 0xd, 0x8, 0xb, 0x2, 0x1, 0x4, 0x7,
    0xa, 0x9, 0xc, 0xf, 0x6, 0x5, 0x0, 0x3, 0x1, 0x2, 0x7, 0x4, 0xd, 0xe, 0xb, 0x8,
    0xf, 0xc, 0x9, 0xa, 0x3, 0x0, 0x5, 0x6, 0x4, 0x7, 0x2, 0x1, 0x8, 0xb, 0xe, 0xd,
    0x7, 0x4, 0x1, 0x2, 0xb, 0x8, 0xd, 0xe, 0xc, 0xf, 0xa, 0x9, 0x0, 0x3, 0x6, 0x5,
    0x2, 0x1, 0x4, 0x7, 0xe, 0xd, 0x8, 0xb, 0x9, 0xa, 0xf, 0xc, 0x5, 0x6, 0x3, 0x0,
    0xd, 0xe, 0xb, 0x8, 0x1, 0x2, 0x7, 0x4, 0x6, 0x5, 0x0, 0x3, 0xa, 0x9, 0xc, 0xf,
    0x8, 0xb, 0xe, 0xd, 0x4, 0x7, 0x2, 0x1, 0x3, 0x0, 0x5, 0x6, 0xf, 0xc, 0x9, 0xa,
    0xe, 0xd, 0x8, 0xb, 0x2, 0x1, 0x4, 0x7, 0x5, 0x6, 0x3, 0x0, 0x9, 0xa, 0xf, 0xc,
    0xb, 0x8, 0xd, 0xe, 0x7, 0x4, 0x1, 0x2, 0x0, 0x3, 0x6, 0x5, 0xc, 0xf, 0xa, 0x9,
    0x4, 0x7, 0x2, 0x1, 0x8, 0xb, 0xe, 0xd, 0xf, 0xc, 0x9, 0xa, 0x3, 0x0, 0x5, 0x6,
    0x1, 0x2, 0x7, 0x4, 0xd, 0xe, 0xb, 0x8, 0xa, 0x9, 0xc, 0xf, 0x6, 0x5, 0x0, 0x3,
    0x9, 0xa, 0xf, 0xc, 0x5, 0x6, 0x3, 0x0, 0x2, 0x1, 0x4, 0x7, 0xe, 0xd, 0x8, 0xb,
    0xc, 0xf, 0xa, 0x9, 0x0, 0x3, 0x6, 0x5, 0x7, 0x4, 0x1, 0x2, 0xb, 0x8, 0xd, 0xe,
    0x3, 0x0, 0x5, 0x6, 0xf, 0xc, 0x9, 0xa, 0x8, 0xb, 0xe, 0xd, 0x4, 0x7, 0x2, 0x1,
    0x6, 0x5, 0x0, 0x3, 0xa, 0x9, 0xc, 0xf, 0xd, 0xe, 0xb, 0x8, 0x1, 0x2, 0x7, 0x4,
]


def _compute_barcode_crc(address_bytes: bytes) -> int:
    """Compute the 4-bit CRC for a barcode from its 8-byte address."""
    crc = 2
    for byte in address_bytes:
        crc = _CRC_TABLE[byte ^ (crc << 4)]
    return crc


def encode_barcode(address_bytes: bytes) -> Optional[str]:
    """Encode an 8-byte MAC address to a Tigo barcode string.

    Returns None if the address doesn't have the 04:C0:5B prefix.

    Args:
        address_bytes: 8-byte IEEE 802.15.4 MAC address.

    Returns:
        Barcode string like "S-1234567A" or None.
    """
    if len(address_bytes) != 8:
        raise ValueError(f"Address must be 8 bytes, got {len(address_bytes)}")

    if address_bytes[0] != 0x04 or address_bytes[1] != 0xC0 or address_bytes[2] != 0x5B:
        return None

    leading_nibble = (address_bytes[3] >> 4) & 0xF

    # Extract remaining 9 nibbles from bytes[3:8] and form a 7-char hex string
    nibbles = [
        address_bytes[3] & 0xF,
        address_bytes[4] >> 4, address_bytes[4] & 0xF,
        address_bytes[5] >> 4, address_bytes[5] & 0xF,
        address_bytes[6] >> 4, address_bytes[6] & 0xF,
        address_bytes[7] >> 4, address_bytes[7] & 0xF,
    ]
    # Build integer from nibbles, format as hex (variable length, strip leading zeros)
    value = 0
    for n in nibbles:
        value = (value << 4) | n
    middle_hex = f'{value:X}'

    crc_nibble = _compute_barcode_crc(address_bytes)
    check_char = _ALPHABET[crc_nibble]

    return f"{leading_nibble:X}-{middle_hex}{check_char}"


def decode_barcode(barcode: str) -> bytes:
    """Decode a Tigo barcode string to an 8-byte MAC address.

    Args:
        barcode: Barcode string like "S-1234567A"

    Returns:
        8-byte address.

    Raises:
        ValueError: If barcode format is invalid or CRC doesn't match.
    """
    if len(barcode) < 5:
        raise ValueError(f"Barcode too short: {barcode}")
    if barcode[1] != '-':
        raise ValueError("Barcode must have '-' at position 1")

    leading_nibble = int(barcode[0], 16)
    middle = barcode[2:-1]
    check_char = barcode[-1]

    rest = int(middle, 16)
    addr_int = rest | ((0x04C05B0 | leading_nibble) << 36)
    address = addr_int.to_bytes(8, 'big')

    # Verify CRC
    crc_nibble = _compute_barcode_crc(address)
    expected_char = _ALPHABET[crc_nibble]
    if check_char != expected_char:
        raise ValueError(f"CRC mismatch: expected '{expected_char}', got '{check_char}'")

    return address


def barcode_from_address(address_bytes: bytes) -> Optional[str]:
    """Convenience: encode barcode from address bytes, returning None if not eligible."""
    try:
        return encode_barcode(address_bytes)
    except (ValueError, IndexError):
        return None
